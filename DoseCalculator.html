<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="color-scheme" content="light dark" />
    <title>Dose Calculator - ToolSuite</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <header class="site-header site-header--compact">
      <div class="container header-row">
        <a class="btn btn--ghost" href="index.html">Back</a>
        <div>
          <h1 class="site-header__title">Dose Calculator</h1>
          <p class="site-header__subtitle">Estimate medicine levels using simple half-life decay.</p>
        </div>
      </div>
    </header>

    <main class="container">
      <section class="card">
        <div class="card__header chart-header">
          <div class="chart-header__left">
            <h2 class="card__title">Serum level over 10 days</h2>
            <p class="card__subtitle">Assumes 100% bioavailability and doses at the start of each day.</p>
            <div class="chart-header__controls">
              <div class="field">
                <label class="field__label" for="halfLife">Half-life</label>
                <div class="control-row">
                  <input class="input input--sm" type="number" id="halfLife" value="6" min="0.1" step="0.1" />
                  <select class="input input--sm" id="halfLifeUnit" aria-label="Half-life unit">
                    <option value="days" selected>Days</option>
                    <option value="hours">Hours</option>
                  </select>
                </div>
              </div>
            </div>
          </div>
          <aside class="stats-panel stats-panel--header">
            <h3 class="stats-title">Chart readout</h3>
            <p class="stats-subtitle">Click the chart to see the value at a particular point.</p>
            <div class="stats-selected" id="selectedValue">Click the chart to pin a value.</div>
            <div class="stats-list">
              <div class="stats-row">
                <span>Average</span>
                <span class="stats-value" id="statAvg">--</span>
              </div>
              <div class="stats-row">
                <span>Min</span>
                <span class="stats-value" id="statMin">--</span>
              </div>
              <div class="stats-row">
                <span>Max</span>
                <span class="stats-value" id="statMax">--</span>
              </div>
              <div class="stats-row">
                <span>Std dev</span>
                <span class="stats-value" id="statStd">--</span>
              </div>
            </div>
          </aside>
        </div>

        <div class="chart-area">
          <canvas id="levelChart" class="chart-canvas" role="img" aria-label="Estimated serum level over time"></canvas>
          <div id="chartTooltip" class="chart-tooltip" role="status" aria-live="polite"></div>
        </div>

        <div class="table-section">
          <h3 class="section__title">Dose schedule</h3>
          <p class="section__subtitle">Enter the dose in milligrams for each day.</p>
          <div class="table-wrapper">
            <table class="dose-table">
              <caption class="table-caption">Doses are applied at the start of each day.</caption>
              <thead>
                <tr>
                  <th scope="col">Mon</th>
                  <th scope="col">Tue</th>
                  <th scope="col">Wed</th>
                  <th scope="col">Thu</th>
                  <th scope="col">Fri</th>
                  <th scope="col">Sat</th>
                  <th scope="col">Sun</th>
                  <th scope="col">Mon</th>
                  <th scope="col">Tue</th>
                  <th scope="col">Wed</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <input class="input input--sm dose-input" type="number" min="0" step="0.1" value="1" aria-label="Dose for Monday day 1" />
                  </td>
                  <td>
                    <input class="input input--sm dose-input" type="number" min="0" step="0.1" value="0" aria-label="Dose for Tuesday day 2" />
                  </td>
                  <td>
                    <input class="input input--sm dose-input" type="number" min="0" step="0.1" value="0" aria-label="Dose for Wednesday day 3" />
                  </td>
                  <td>
                    <input class="input input--sm dose-input" type="number" min="0" step="0.1" value="0" aria-label="Dose for Thursday day 4" />
                  </td>
                  <td>
                    <input class="input input--sm dose-input" type="number" min="0" step="0.1" value="0" aria-label="Dose for Friday day 5" />
                  </td>
                  <td>
                    <input class="input input--sm dose-input" type="number" min="0" step="0.1" value="0" aria-label="Dose for Saturday day 6" />
                  </td>
                  <td>
                    <input class="input input--sm dose-input" type="number" min="0" step="0.1" value="0" aria-label="Dose for Sunday day 7" />
                  </td>
                  <td>
                    <input class="input input--sm dose-input" type="number" min="0" step="0.1" value="0" aria-label="Dose for Monday day 8" />
                  </td>
                  <td>
                    <input class="input input--sm dose-input" type="number" min="0" step="0.1" value="0" aria-label="Dose for Tuesday day 9" />
                  </td>
                  <td>
                    <input class="input input--sm dose-input" type="number" min="0" step="0.1" value="0" aria-label="Dose for Wednesday day 10" />
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </section>

      <footer class="footer">
        <p class="footer__text">For planning only; not medical advice.</p>
      </footer>
    </main>

    <script>
      const dayInputs = Array.from(document.querySelectorAll(".dose-input"));
      const halfLifeInput = document.getElementById("halfLife");
      const halfLifeUnit = document.getElementById("halfLifeUnit");
      const chart = document.getElementById("levelChart");
      const chartArea = chart.closest(".chart-area");
      const tooltip = document.getElementById("chartTooltip");
      const ctx = chart.getContext("2d");
      const selectedValue = document.getElementById("selectedValue");
      const statAvg = document.getElementById("statAvg");
      const statMin = document.getElementById("statMin");
      const statMax = document.getElementById("statMax");
      const statStd = document.getElementById("statStd");

      const HOURS_PER_DAY = 24;
      const DEFAULT_HALF_LIFE = 6;
      const chartState = {
        points: [],
        totalHours: 0,
        safeMax: 1,
        avgLevel: 0,
        selectedHour: null,
        padding: null,
        plotWidth: 0,
        plotHeight: 0,
        hasData: false
      };
      let rafId = null;

      function hideTooltip() {
        if (!tooltip) return;
        tooltip.classList.remove("is-visible");
      }

      function getEventClientPosition(event) {
        if (event.touches && event.touches.length > 0) {
          return { x: event.touches[0].clientX, y: event.touches[0].clientY };
        }
        if (event.changedTouches && event.changedTouches.length > 0) {
          return { x: event.changedTouches[0].clientX, y: event.changedTouches[0].clientY };
        }
        return { x: event.clientX, y: event.clientY };
      }

      function formatMg(value) {
        return `${value.toFixed(2)}mg`;
      }

      function updateStatsDisplay(stats, selectedPoint, hasData) {
        if (!statAvg || !statMin || !statMax || !statStd || !selectedValue) return;
        if (!hasData) {
          statAvg.textContent = "--";
          statMin.textContent = "--";
          statMax.textContent = "--";
          statStd.textContent = "--";
          selectedValue.textContent = "No data yet.";
          return;
        }
        statAvg.textContent = formatMg(stats.avg);
        statMin.textContent = formatMg(stats.min);
        statMax.textContent = formatMg(stats.max);
        statStd.textContent = formatMg(stats.std);
        selectedValue.textContent = selectedPoint
          ? `Day ${Math.floor(selectedPoint.hour / HOURS_PER_DAY) + 1}: ${formatMg(selectedPoint.level)}`
          : "Click the chart to pin a value.";
      }

      function scheduleDraw() {
        if (rafId) return;
        hideTooltip();
        rafId = requestAnimationFrame(() => {
          rafId = null;
          drawChart();
        });
      }

      function getHalfLifeHours() {
        const rawValue = parseFloat(halfLifeInput.value);
        const safeValue = Number.isFinite(rawValue) && rawValue > 0 ? rawValue : DEFAULT_HALF_LIFE;
        if (!Number.isFinite(rawValue) || rawValue <= 0) {
          halfLifeInput.value = String(DEFAULT_HALF_LIFE);
        }
        return halfLifeUnit.value === "hours" ? safeValue : safeValue * HOURS_PER_DAY;
      }

      function getDoses() {
        return dayInputs.map((input) => {
          const value = parseFloat(input.value);
          return Number.isFinite(value) && value > 0 ? value : 0;
        });
      }

      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const rect = chart.getBoundingClientRect();
        const width = Math.max(1, rect.width);
        const height = Math.max(1, rect.height);
        chart.width = Math.round(width * dpr);
        chart.height = Math.round(height * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        return { width, height };
      }

      function getThemeColors() {
        const styles = getComputedStyle(document.documentElement);
        return {
          surface: styles.getPropertyValue("--surface").trim() || "#ffffff",
          border: styles.getPropertyValue("--border").trim() || "#d8dee9",
          primary: styles.getPropertyValue("--primary").trim() || "#2563eb",
          muted: styles.getPropertyValue("--muted").trim() || "#475569"
        };
      }

      function computePoints(halfLifeHours, doses) {
        const totalDays = doses.length;
        const totalHours = totalDays * HOURS_PER_DAY;
        const stepHours = 1;
        const points = [];

        for (let hour = 0; hour <= totalHours; hour += stepHours) {
          let level = 0;
          for (let day = 0; day < totalDays; day++) {
            const dose = doses[day];
            if (dose <= 0) continue;
            const doseHour = day * HOURS_PER_DAY;
            if (hour >= doseHour) {
              level += dose * Math.pow(0.5, (hour - doseHour) / halfLifeHours);
            }
          }
          points.push({ hour, level });
        }

        return { points, totalHours };
      }

      function computeStats(points) {
        if (!points.length) {
          return {
            avg: 0,
            min: 0,
            max: 0,
            std: 0
          };
        }
        let sum = 0;
        let min = Infinity;
        let max = -Infinity;
        points.forEach((point) => {
          sum += point.level;
          if (point.level < min) min = point.level;
          if (point.level > max) max = point.level;
        });
        const avg = sum / points.length;
        let variance = 0;
        points.forEach((point) => {
          variance += (point.level - avg) ** 2;
        });
        const std = Math.sqrt(variance / points.length);
        return { avg, min, max, std };
      }

      function drawAxisLabels(width, height, padding, plotWidth, plotHeight, colors) {
        ctx.save();
        ctx.fillStyle = colors.muted;
        ctx.font =
          "12px system-ui, -apple-system, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "alphabetic";
        ctx.fillText("Days", padding.left + plotWidth / 2, height - 6);
        ctx.translate(12, padding.top + plotHeight / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.textBaseline = "middle";
        ctx.fillText("Level (mg)", 0, 0);
        ctx.restore();
      }

      function positionTooltip(x, y, label) {
        if (!tooltip || !chartArea) return;
        tooltip.textContent = label;
        const areaWidth = chartArea.clientWidth;
        const areaHeight = chartArea.clientHeight;
        const tooltipWidth = tooltip.offsetWidth;
        const tooltipHeight = tooltip.offsetHeight;
        const minLeft = tooltipWidth / 2 + 8;
        const maxLeft = areaWidth - tooltipWidth / 2 - 8;
        const minTop = tooltipHeight + 12;
        let left = Math.min(Math.max(x, minLeft), maxLeft);
        let top = Math.max(y, minTop);
        top = Math.min(top, areaHeight - 8);
        tooltip.style.left = `${left}px`;
        tooltip.style.top = `${top}px`;
        tooltip.classList.add("is-visible");
      }

      function handleHover(event) {
        if (!chartState.hasData || !tooltip) return;
        const rect = chart.getBoundingClientRect();
        const position = getEventClientPosition(event);
        const x = position.x - rect.left;
        const y = position.y - rect.top;
        const { padding, plotWidth, plotHeight, totalHours, points, safeMax, avgLevel } = chartState;
        if (
          x < padding.left ||
          x > padding.left + plotWidth ||
          y < padding.top ||
          y > padding.top + plotHeight
        ) {
          hideTooltip();
          return;
        }

        if (avgLevel > 0) {
          const avgY = padding.top + plotHeight - (avgLevel / safeMax) * plotHeight;
          if (Math.abs(y - avgY) <= 6) {
            positionTooltip(x, avgY, `Average: ${avgLevel.toFixed(2)}mg`);
            return;
          }
        }

        const hour = Math.round(((x - padding.left) / plotWidth) * totalHours);
        const index = Math.min(Math.max(hour, 0), points.length - 1);
        const point = points[index];
        if (!point || point.level <= 0) {
          hideTooltip();
          return;
        }

        const levelX = padding.left + (point.hour / totalHours) * plotWidth;
        const levelY = padding.top + plotHeight - (point.level / safeMax) * plotHeight;
        const dayNumber = Math.floor(point.hour / HOURS_PER_DAY) + 1;
        positionTooltip(levelX, levelY, `Day ${dayNumber}: ${point.level.toFixed(2)}mg`);
      }

      function handleClick(event) {
        if (!chartState.hasData) return;
        const rect = chart.getBoundingClientRect();
        const position = getEventClientPosition(event);
        const x = position.x - rect.left;
        const y = position.y - rect.top;
        const { padding, plotWidth, plotHeight, totalHours, points } = chartState;
        if (
          x < padding.left ||
          x > padding.left + plotWidth ||
          y < padding.top ||
          y > padding.top + plotHeight
        ) {
          return;
        }

        const hour = Math.round(((x - padding.left) / plotWidth) * totalHours);
        const index = Math.min(Math.max(hour, 0), points.length - 1);
        chartState.selectedHour = points[index].hour;
        scheduleDraw();
      }

      function handleTouch(event) {
        event.preventDefault();
        handleHover(event);
      }

      function handleTouchEnd(event) {
        handleClick(event);
        hideTooltip();
      }

      function drawChart() {
        if (!chart) return;
        const { width, height } = resizeCanvas();
        const colors = getThemeColors();
        const padding = { top: 16, right: 16, bottom: 24, left: 36 };
        const plotWidth = Math.max(1, width - padding.left - padding.right);
        const plotHeight = Math.max(1, height - padding.top - padding.bottom);

        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = colors.surface;
        ctx.fillRect(0, 0, width, height);

        const halfLifeHours = getHalfLifeHours();
        const doses = getDoses();
        const totalDays = doses.length;
        const { points, totalHours } = computePoints(halfLifeHours, doses);
        const stats = computeStats(points);
        const maxLevel = stats.max;
        const safeMax = maxLevel > 0 ? maxLevel : 1;
        const avgLevel = stats.avg;
        let selectedPoint = null;
        if (chartState.selectedHour !== null && points.length > 0) {
          const index = Math.min(Math.max(chartState.selectedHour, 0), points.length - 1);
          selectedPoint = points[index];
        }
        chartState.points = points;
        chartState.totalHours = totalHours;
        chartState.safeMax = safeMax;
        chartState.avgLevel = avgLevel;
        chartState.selectedPoint = selectedPoint;
        chartState.padding = padding;
        chartState.plotWidth = plotWidth;
        chartState.plotHeight = plotHeight;
        chartState.hasData = maxLevel > 0;
        updateStatsDisplay(stats, selectedPoint, chartState.hasData);

        ctx.lineWidth = 1;
        ctx.strokeStyle = colors.border;
        ctx.globalAlpha = 0.35;

        for (let i = 0; i <= 4; i++) {
          const y = padding.top + (plotHeight * i) / 4;
          ctx.beginPath();
          ctx.moveTo(padding.left, y);
          ctx.lineTo(padding.left + plotWidth, y);
          ctx.stroke();
        }

        for (let day = 0; day <= totalDays; day++) {
          const x = padding.left + (plotWidth * day) / totalDays;
          ctx.beginPath();
          ctx.moveTo(x, padding.top);
          ctx.lineTo(x, padding.top + plotHeight);
          ctx.stroke();
        }

        ctx.globalAlpha = 1;
        drawAxisLabels(width, height, padding, plotWidth, plotHeight, colors);

        if (maxLevel === 0) {
          ctx.fillStyle = colors.muted;
          ctx.font =
            "13px system-ui, -apple-system, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif";
          ctx.textAlign = "center";
          ctx.fillText("Enter a dose to see the curve", width / 2, height / 2);
          hideTooltip();
          return;
        }

        ctx.beginPath();
        points.forEach((point, index) => {
          const x = padding.left + (point.hour / totalHours) * plotWidth;
          const y = padding.top + plotHeight - (point.level / safeMax) * plotHeight;
          if (index === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });
        ctx.lineTo(padding.left + plotWidth, padding.top + plotHeight);
        ctx.lineTo(padding.left, padding.top + plotHeight);
        ctx.closePath();
        ctx.fillStyle = colors.primary;
        ctx.globalAlpha = 0.15;
        ctx.fill();
        ctx.globalAlpha = 1;

        ctx.beginPath();
        points.forEach((point, index) => {
          const x = padding.left + (point.hour / totalHours) * plotWidth;
          const y = padding.top + plotHeight - (point.level / safeMax) * plotHeight;
          if (index === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });
        ctx.strokeStyle = colors.primary;
        ctx.lineWidth = 2;
        ctx.stroke();

        if (avgLevel > 0) {
          const avgY = padding.top + plotHeight - (avgLevel / safeMax) * plotHeight;
          ctx.save();
          ctx.strokeStyle = colors.muted;
          ctx.lineWidth = 1.5;
          ctx.globalAlpha = 0.7;
          ctx.setLineDash([6, 6]);
          ctx.beginPath();
          ctx.moveTo(padding.left, avgY);
          ctx.lineTo(padding.left + plotWidth, avgY);
          ctx.stroke();
          ctx.restore();
        }

        if (selectedPoint) {
          const markerX = padding.left + (selectedPoint.hour / totalHours) * plotWidth;
          const markerY = padding.top + plotHeight - (selectedPoint.level / safeMax) * plotHeight;
          ctx.save();
          ctx.fillStyle = colors.primary;
          ctx.strokeStyle = colors.surface;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(markerX, markerY, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          ctx.restore();
        }
      }

      const controls = [...dayInputs, halfLifeInput, halfLifeUnit];
      controls.forEach((control) => control.addEventListener("input", scheduleDraw));
      halfLifeUnit.addEventListener("change", scheduleDraw);
      chart.addEventListener("mousemove", handleHover);
      chart.addEventListener("click", handleClick);
      chart.addEventListener("mouseleave", hideTooltip);
      chart.addEventListener("touchstart", handleTouch, { passive: false });
      chart.addEventListener("touchmove", handleTouch, { passive: false });
      chart.addEventListener("touchend", handleTouchEnd);
      chart.addEventListener("touchcancel", handleTouchEnd);
      window.addEventListener("resize", scheduleDraw);

      if (window.matchMedia) {
        const schemeQuery = window.matchMedia("(prefers-color-scheme: dark)");
        if (schemeQuery.addEventListener) {
          schemeQuery.addEventListener("change", scheduleDraw);
        } else if (schemeQuery.addListener) {
          schemeQuery.addListener(scheduleDraw);
        }
      }

      scheduleDraw();
    </script>
  </body>
</html>
